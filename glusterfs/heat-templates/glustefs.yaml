heat_template_version: 2018-03-02
description: Deploying a set of server for a GlusterFS Cluster

parameters:
    image:
        type: string
        label: Image ID or Name
        description: An image to run a server(s) from
        default: CentOS-7

    flavor:
        type: string    
        label: Flavor ID or Name
        description: A flavor for a server(s)
        default: v1.small

    frontend_network:
        type: string
        label: Subnet ID or Name
        description: A public network for connecting clients to a cluster
        default: {{ frontend_network }}

    backend_network:
        type: string
        label: Subnet ID or Name
        description: A private network for the cluster's internals
        default: {{ backend_network }}

    sshkey:
        type: string
        label: SSHPair ID or Name
        description: SSH keypair, those public key will be injected into the cluster nodes
        default: {{ sshkey }}

    allowed_tcp_ports:
        type: comma_delimited_list
        label: A list of ports
        description: A list of tcp ports which will be accessed via a security group
        default: "22,111,2049,139,445,965,2049,631"

    allowed_udp_ports:
        type: comma_delimited_list
        label: A list of ports
        description: A list of udp ports which will be accessed via a security group    
        default: "111,963"


    volume_size:
        type: number
        label: Disk size
        description: Size of a single volume in Gb
        default: {{ volume_size | default(10) }}

    volume_type:
        type: string
        label: Storage volume type
        description: Type of a volume as defined in OpenStack database
        default: {{ volume_type | default('CephStorage') }}




resources:


    tcp_ports:
        type: OS::Neutron::SecurityGroup
        properties:
            rules:
                repeat:
                    for_each:
                        <%port%>: { get_param: allowed_tcp_ports }
                    template:
                        direction: ingress
                        ethertype: IPv4
                        port_range_min: <%port%>
                        port_range_max: <%port%>
                        protocol: tcp
                        remote_ip_prefix: 0.0.0.0/0    
   
    udp_ports:
        type: OS::Neutron::SecurityGroup
        properties:
            rules:
                repeat:
                    for_each:
                        <%port%>: { get_param: allowed_udp_ports }
                    template:
                        direction: ingress
                        ethertype: IPv4
                        port_range_min: <%port%>
                        port_range_max: <%port%>
                        protocol: tcp
                        remote_ip_prefix: 0.0.0.0/0    
    icmp_ports:
        type: OS::Neutron::SecurityGroup
        properties:
            rules:
              - direction: ingress
                ethertype: IPv4
                protocol: icmp
                remote_ip_prefix: 0.0.0.0/0
     

    all_ports:
        type: OS::Neutron::SecurityGroup
        properties: 
            rules:
              - direction: ingress
                ethertype: IPv4
                remote_ip_prefix: 0.0.0.0/0

{% set n_servers = num_servers|int %}
{% for num in range(0, n_servers)%} 
### -------  Server {{ loop.index }}
{% set outer_loop = loop %}
{% for volid in range(0, volume_count|int) %}
    s{{ outer_loop.index }}vol{{ loop.index }}:
        type: OS::Cinder::Volume
        properties:
            size: { get_param: volume_size }
            volume_type: { get_param: volume_type }

    s{{ outer_loop.index }}vol{{ loop.index }}attach:
        type: OS::Cinder::VolumeAttachment
        properties:
            volume_id: { get_resource: s{{ outer_loop.index }}vol{{ loop.index }} }
            instance_uuid: { get_resource: server{{ outer_loop.index }} }
{% endfor %}

    s{{ loop.index }}port01:
        type: OS::Neutron::Port
        properties:
            network_id: { get_param: frontend_network }
            security_groups:
              - { get_resource: tcp_ports }
              - { get_resource: udp_ports }
              - { get_resource: icmp_ports }

    s{{ loop.index }}port02:
        type: OS::Neutron::Port
        properties:
            network_id: { get_param: backend_network }
            security_groups:
              - { get_resource: all_ports }
  
    server{{ loop.index }}:
        type: OS::Nova::Server
        properties:
            name:
                str_replace:
                    template: $stackname-node{{ loop.index }}
                    params:
                        $stackname: { get_param: "OS::stack_name" }
            image: { get_param: image } 
            flavor: { get_param: flavor }
            key_name: { get_param: sshkey }
            # user_data: { get_param: userdata_script }
            user_data:
                str_replace:
                    template: |
                        #!/bin/bash
                        import sys
                        cat << EOF > /tmp/helper.py
                        #!/usr/bin/env python
                        import sys
                        def calcDottedNetmask(mask):
                            bits = 0
                            for i in xrange(32-mask,32):
                                bits |= (1 << i)
                            return "%d.%d.%d.%d" % ((bits & 0xff000000) >> 24, (bits & 0xff0000) >> 16, (bits & 0xff00) >> 8 , (bits & 0xff))
                        print(calcDottedNetmask(int(sys.argv[1].split('/')[1])))
                        EOF
                
                        cat << EOF | sudo tee /etc/sysconfig/network-scripts/ifcfg-eth0
                        DEVICE=eth0
                        BOOTPROTO=static
                        ONBOOT=yes
                        NM_CONTROLLED=no
                        IPADDR=$port1_ipaddr
                        NETMASK=`python /tmp/helper.py $port1_netmask`
                        GATEWAY=$port1_gateway
                        DNS1=$port1_dns1
                        DNS2=$port1_dns2
                        EOF
    
                        cat << EOF | sudo tee /etc/sysconfig/network-scripts/ifcfg-eth1
                        DEVICE=eth1
                        BOOTPROTO=static
                        ONBOOT=yes
                        NM_CONTROLLED=no
                        IPADDR=$port2_ipaddr
                        NETMASK=`python /tmp/helper.py $port2_netmask`
                        EOF
                        rm -f /tmp/helper.py || true 
                        sudo yum install -y epel-release
                        sudo yum update -y 
                        touch /.installed
                        sudo reboot
                    params:
                        $port1_ipaddr:  { get_attr: [ s{{ loop.index }}port01, fixed_ips, 0, ip_address ]}
                        $port1_netmask: { get_attr: [ s{{ loop.index }}port01, subnets, 0, cidr ]}
                        $port1_gateway: { get_attr: [ s{{ loop.index }}port01, subnets, 0, gateway_ip ]}
                        $port1_dns1:    { get_attr: [ s{{ loop.index }}port01, subnets, 0, dns_nameservers, 0 ]}
                        $port1_dns2:    { get_attr: [ s{{ loop.index }}port01, subnets, 0, dns_nameservers, 1 ]}
                        $port2_ipaddr:  { get_attr: [ s{{ loop.index }}port02, fixed_ips, 0, ip_address ]}
                        $port2_netmask: { get_attr: [ s{{ loop.index }}port02, subnets, 0, cidr ]}
            networks: [ port: { get_resource: s{{ loop.index }}port01 }, port: { get_resource: s{{ loop.index }}port02 }]

{% endfor %} 


outputs:
{% for num in range(0, n_servers) %}
    srv{{ loop.index }}port1_ip: { value: { get_attr: [ s{{ loop.index }}port01, fixed_ips, 0, ip_address ]}}
    srv{{ loop.index }}port2_ip: { value: { get_attr: [ s{{ loop.index }}port02, fixed_ips, 0, ip_address ]}}
{% endfor %}
 
